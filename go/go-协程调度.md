## Go协程调度器的三个基本对象

Go的协程（goroutine）和我们常见的线程（Thread）一样，拥有其调度器

​	G（Goroutine），代表协程，也就是每次代码中使用go关键词的时候创建的对象

​	M（Work Thread），工作线程

​	P（processor）,代表一个处理器，又称上下文

### G-M-P三者的关系与特点：

1. 每一个运行的M都必须绑定一个P，线程M创建后会去检查G对象
2. 每一个P都保存着一个协程G的队列
3. 除了每个P自身保存的G队列以外，还有一个全局的G队列
4. M从队列中提取G，并执行
5. P的个数就是GOMAXOPROCS（最大256），启动时固定的，一般不修改
6. M的个数和P的个数不一定一张多（会有休眠的M或P不绑定M）最大（10000）
7. P是用一个全局数组（255）来保存的，并维护着一个全局的P空闲链表

### 局部G队列与全局G队列的关系

全局G任务队列会和各个本地G任务队列按照一定的策略相互交换。就是协程任务的交换

G任务的执行顺序是，先从本地队列找，没有则从全局队列找

转移

​	局部和全部，全局G个数/P个数

​	局部与局部，一次性转移一半

### Gorutine从入队到执行

​	1.当我们传教一个G对象，就是forutine，它会加入到本地队列或者全局队列

​	2.如果还有空虚的P，则创建一个M绑定一个空闲的p

​		1.先找到一个空闲的p，如果没有则直接返回

​		2.P个数不会占用超过自己设定的cpu个数

​		3.P再被M绑定后，就会初始化自己的G队列，此时是一个空队列

​		4.无论再那个M中创建了一个G，只要P有空闲的，就会引起新M的创建，不需要考虑当前所在M中绑定的P的G队列是否已满，新创建的M所绑的P的初始化队列会从其他G队列中取任务过来

​	3.M会启动一个底层线程，循环执行能找到的G任务。这里的寻找的G从下面几方面找

​		当前M所绑定的P的G队列中找

​		去别的P的G队列中找

​		取全局G队列中找

​	4.G任务的执行顺序是，先从本地队列找，本地队列没有则从全局队列找

​	5.程序启动的时候，首先跑的是主线程，然后这个主线程会绑定第一个P

​	6.入口main函数，其实是作为一个goroutine来执行的

### 如果一个G任务执行时间太长，它就会一直占用 M 线程，由于队列的G任务是顺序执行的，其它G任务就会阻塞，如何避免该情况发生？

启程的切换时间是10ms，也就是说goroutine最多执行10ms就会被M切换到下一个G。这个过程，被称为中断，挂起。

原理：

go程序启动时会首先创建一个特殊的内核线程sysmon，用来监控和管理，其内部是一个循环：

1.记录所有P的G任务的计数schedtick，schedtick会在每执行一个G任务后递增

2.如果检查到schedtick一直没有递增，说明这个p一直在执行同一个G任务，如果超过10ms，就在这个G任务的栈信息里面家一个tag标记

3.然后这个G任务在执行的时候，如果遇到非内联函数调用，就会检查一次这个标记，然后中断自己，把自己加到队列末尾，执行下一个G

4.如果没有遇到非内联函数调用的话，那就会一直执行这个G任务，直到它自己结束；如果是个死循环，并且GOMAXPROCS=1的话。那么一直只会有一个P与一个M，并且队列中其他的G不会被执行！



中断后的恢复

1中断的时候将寄存器理的栈信息，保存到自己的G对象里面

2.当再次轮到自己执行的时候，将自己保存的栈信息复制到寄存器里面，这样就接着上次之后运行

### GOMAXPROCS--性能调优

GOMAXPROCS就是go中runtime包的一个函数。它设置了P的最多的个数。着也就直接导致了M最多的个数是多少，而M的个数就决定了各个G队列能同时被多少M线程来进行调取执行

我们一般将GOMAXPROCS的个数设置为cpu的核数，需要注意的是：

​	go 1.5版本之前的GOMAXPROCS默认是1

​	go 1.5版本之后的GOMAXPROCS默认是Num of cpu

